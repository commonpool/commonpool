// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/commonpool/backend/amqp"
	"sync"
)

// Ensure, that AmqpChannelMock does implement amqp.AmqpChannel.
// If this is not the case, regenerate this file with moq.
var _ amqp.AmqpChannel = &AmqpChannelMock{}

// AmqpChannelMock is a mock implementation of amqp.AmqpChannel.
//
//     func TestSomethingThatUsesAmqpChannel(t *testing.T) {
//
//         // make and configure a mocked amqp.AmqpChannel
//         mockedAmqpChannel := &AmqpChannelMock{
//             CloseFunc: func() error {
// 	               panic("mock out the Close method")
//             },
//             ConsumeFunc: func(ctx context.Context, queue string, consumer string, autoAck bool, exclusive bool, noLocal bool, noWait bool, args amqp.AmqpArgs) (<-chan amqp.AmqpDelivery, error) {
// 	               panic("mock out the Consume method")
//             },
//             ExchangeBindFunc: func(ctx context.Context, destination string, key string, source string, nowait bool, args amqp.AmqpArgs) error {
// 	               panic("mock out the ExchangeBind method")
//             },
//             ExchangeDeclareFunc: func(ctx context.Context, name string, exchangeType string, durable bool, autoDelete bool, internal bool, nowait bool, args amqp.AmqpArgs) error {
// 	               panic("mock out the ExchangeDeclare method")
//             },
//             ExchangeDeleteFunc: func(ctx context.Context, name string, ifUnused bool, noWait bool) error {
// 	               panic("mock out the ExchangeDelete method")
//             },
//             ExchangeUnbindFunc: func(ctx context.Context, destination string, key string, source string, noWait bool, args amqp.AmqpArgs) error {
// 	               panic("mock out the ExchangeUnbind method")
//             },
//             PublishFunc: func(ctx context.Context, exchange string, key string, mandatory bool, immediate bool, publishing amqp.AmqpPublishing) error {
// 	               panic("mock out the Publish method")
//             },
//             QueueBindFunc: func(ctx context.Context, name string, key string, exchange string, nowait bool, args amqp.AmqpArgs) error {
// 	               panic("mock out the QueueBind method")
//             },
//             QueueDeclareFunc: func(ctx context.Context, name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args amqp.AmqpArgs) error {
// 	               panic("mock out the QueueDeclare method")
//             },
//             QueueDeleteFunc: func(ctx context.Context, name string, ifUnused bool, ifEmpty bool, noWait bool) error {
// 	               panic("mock out the QueueDelete method")
//             },
//             QueueUnbindFunc: func(ctx context.Context, name string, key string, exchange string, args amqp.AmqpArgs) error {
// 	               panic("mock out the QueueUnbind method")
//             },
//         }
//
//         // use mockedAmqpChannel in code that requires amqp.AmqpChannel
//         // and then make assertions.
//
//     }
type AmqpChannelMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ConsumeFunc mocks the Consume method.
	ConsumeFunc func(ctx context.Context, queue string, consumer string, autoAck bool, exclusive bool, noLocal bool, noWait bool, args amqp.AmqpArgs) (<-chan amqp.AmqpDelivery, error)

	// ExchangeBindFunc mocks the ExchangeBind method.
	ExchangeBindFunc func(ctx context.Context, destination string, key string, source string, nowait bool, args amqp.AmqpArgs) error

	// ExchangeDeclareFunc mocks the ExchangeDeclare method.
	ExchangeDeclareFunc func(ctx context.Context, name string, exchangeType string, durable bool, autoDelete bool, internal bool, nowait bool, args amqp.AmqpArgs) error

	// ExchangeDeleteFunc mocks the ExchangeDelete method.
	ExchangeDeleteFunc func(ctx context.Context, name string, ifUnused bool, noWait bool) error

	// ExchangeUnbindFunc mocks the ExchangeUnbind method.
	ExchangeUnbindFunc func(ctx context.Context, destination string, key string, source string, noWait bool, args amqp.AmqpArgs) error

	// PublishFunc mocks the Publish method.
	PublishFunc func(ctx context.Context, exchange string, key string, mandatory bool, immediate bool, publishing amqp.AmqpPublishing) error

	// QueueBindFunc mocks the QueueBind method.
	QueueBindFunc func(ctx context.Context, name string, key string, exchange string, nowait bool, args amqp.AmqpArgs) error

	// QueueDeclareFunc mocks the QueueDeclare method.
	QueueDeclareFunc func(ctx context.Context, name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args amqp.AmqpArgs) error

	// QueueDeleteFunc mocks the QueueDelete method.
	QueueDeleteFunc func(ctx context.Context, name string, ifUnused bool, ifEmpty bool, noWait bool) error

	// QueueUnbindFunc mocks the QueueUnbind method.
	QueueUnbindFunc func(ctx context.Context, name string, key string, exchange string, args amqp.AmqpArgs) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Consume holds details about calls to the Consume method.
		Consume []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Queue is the queue argument value.
			Queue string
			// Consumer is the consumer argument value.
			Consumer string
			// AutoAck is the autoAck argument value.
			AutoAck bool
			// Exclusive is the exclusive argument value.
			Exclusive bool
			// NoLocal is the noLocal argument value.
			NoLocal bool
			// NoWait is the noWait argument value.
			NoWait bool
			// Args is the args argument value.
			Args amqp.AmqpArgs
		}
		// ExchangeBind holds details about calls to the ExchangeBind method.
		ExchangeBind []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Key is the key argument value.
			Key string
			// Source is the source argument value.
			Source string
			// Nowait is the nowait argument value.
			Nowait bool
			// Args is the args argument value.
			Args amqp.AmqpArgs
		}
		// ExchangeDeclare holds details about calls to the ExchangeDeclare method.
		ExchangeDeclare []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// ExchangeType is the exchangeType argument value.
			ExchangeType string
			// Durable is the durable argument value.
			Durable bool
			// AutoDelete is the autoDelete argument value.
			AutoDelete bool
			// Internal is the internal argument value.
			Internal bool
			// Nowait is the nowait argument value.
			Nowait bool
			// Args is the args argument value.
			Args amqp.AmqpArgs
		}
		// ExchangeDelete holds details about calls to the ExchangeDelete method.
		ExchangeDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// IfUnused is the ifUnused argument value.
			IfUnused bool
			// NoWait is the noWait argument value.
			NoWait bool
		}
		// ExchangeUnbind holds details about calls to the ExchangeUnbind method.
		ExchangeUnbind []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Key is the key argument value.
			Key string
			// Source is the source argument value.
			Source string
			// NoWait is the noWait argument value.
			NoWait bool
			// Args is the args argument value.
			Args amqp.AmqpArgs
		}
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Exchange is the exchange argument value.
			Exchange string
			// Key is the key argument value.
			Key string
			// Mandatory is the mandatory argument value.
			Mandatory bool
			// Immediate is the immediate argument value.
			Immediate bool
			// Publishing is the publishing argument value.
			Publishing amqp.AmqpPublishing
		}
		// QueueBind holds details about calls to the QueueBind method.
		QueueBind []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Key is the key argument value.
			Key string
			// Exchange is the exchange argument value.
			Exchange string
			// Nowait is the nowait argument value.
			Nowait bool
			// Args is the args argument value.
			Args amqp.AmqpArgs
		}
		// QueueDeclare holds details about calls to the QueueDeclare method.
		QueueDeclare []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Durable is the durable argument value.
			Durable bool
			// AutoDelete is the autoDelete argument value.
			AutoDelete bool
			// Exclusive is the exclusive argument value.
			Exclusive bool
			// NoWait is the noWait argument value.
			NoWait bool
			// Args is the args argument value.
			Args amqp.AmqpArgs
		}
		// QueueDelete holds details about calls to the QueueDelete method.
		QueueDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// IfUnused is the ifUnused argument value.
			IfUnused bool
			// IfEmpty is the ifEmpty argument value.
			IfEmpty bool
			// NoWait is the noWait argument value.
			NoWait bool
		}
		// QueueUnbind holds details about calls to the QueueUnbind method.
		QueueUnbind []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Key is the key argument value.
			Key string
			// Exchange is the exchange argument value.
			Exchange string
			// Args is the args argument value.
			Args amqp.AmqpArgs
		}
	}
	lockClose           sync.RWMutex
	lockConsume         sync.RWMutex
	lockExchangeBind    sync.RWMutex
	lockExchangeDeclare sync.RWMutex
	lockExchangeDelete  sync.RWMutex
	lockExchangeUnbind  sync.RWMutex
	lockPublish         sync.RWMutex
	lockQueueBind       sync.RWMutex
	lockQueueDeclare    sync.RWMutex
	lockQueueDelete     sync.RWMutex
	lockQueueUnbind     sync.RWMutex
}

// Close calls CloseFunc.
func (mock *AmqpChannelMock) Close() error {
	if mock.CloseFunc == nil {
		panic("AmqpChannelMock.CloseFunc: method is nil but AmqpChannel.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedAmqpChannel.CloseCalls())
func (mock *AmqpChannelMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Consume calls ConsumeFunc.
func (mock *AmqpChannelMock) Consume(ctx context.Context, queue string, consumer string, autoAck bool, exclusive bool, noLocal bool, noWait bool, args amqp.AmqpArgs) (<-chan amqp.AmqpDelivery, error) {
	if mock.ConsumeFunc == nil {
		panic("AmqpChannelMock.ConsumeFunc: method is nil but AmqpChannel.Consume was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Queue     string
		Consumer  string
		AutoAck   bool
		Exclusive bool
		NoLocal   bool
		NoWait    bool
		Args      amqp.AmqpArgs
	}{
		Ctx:       ctx,
		Queue:     queue,
		Consumer:  consumer,
		AutoAck:   autoAck,
		Exclusive: exclusive,
		NoLocal:   noLocal,
		NoWait:    noWait,
		Args:      args,
	}
	mock.lockConsume.Lock()
	mock.calls.Consume = append(mock.calls.Consume, callInfo)
	mock.lockConsume.Unlock()
	return mock.ConsumeFunc(ctx, queue, consumer, autoAck, exclusive, noLocal, noWait, args)
}

// ConsumeCalls gets all the calls that were made to Consume.
// Check the length with:
//     len(mockedAmqpChannel.ConsumeCalls())
func (mock *AmqpChannelMock) ConsumeCalls() []struct {
	Ctx       context.Context
	Queue     string
	Consumer  string
	AutoAck   bool
	Exclusive bool
	NoLocal   bool
	NoWait    bool
	Args      amqp.AmqpArgs
} {
	var calls []struct {
		Ctx       context.Context
		Queue     string
		Consumer  string
		AutoAck   bool
		Exclusive bool
		NoLocal   bool
		NoWait    bool
		Args      amqp.AmqpArgs
	}
	mock.lockConsume.RLock()
	calls = mock.calls.Consume
	mock.lockConsume.RUnlock()
	return calls
}

// ExchangeBind calls ExchangeBindFunc.
func (mock *AmqpChannelMock) ExchangeBind(ctx context.Context, destination string, key string, source string, nowait bool, args amqp.AmqpArgs) error {
	if mock.ExchangeBindFunc == nil {
		panic("AmqpChannelMock.ExchangeBindFunc: method is nil but AmqpChannel.ExchangeBind was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Key         string
		Source      string
		Nowait      bool
		Args        amqp.AmqpArgs
	}{
		Ctx:         ctx,
		Destination: destination,
		Key:         key,
		Source:      source,
		Nowait:      nowait,
		Args:        args,
	}
	mock.lockExchangeBind.Lock()
	mock.calls.ExchangeBind = append(mock.calls.ExchangeBind, callInfo)
	mock.lockExchangeBind.Unlock()
	return mock.ExchangeBindFunc(ctx, destination, key, source, nowait, args)
}

// ExchangeBindCalls gets all the calls that were made to ExchangeBind.
// Check the length with:
//     len(mockedAmqpChannel.ExchangeBindCalls())
func (mock *AmqpChannelMock) ExchangeBindCalls() []struct {
	Ctx         context.Context
	Destination string
	Key         string
	Source      string
	Nowait      bool
	Args        amqp.AmqpArgs
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Key         string
		Source      string
		Nowait      bool
		Args        amqp.AmqpArgs
	}
	mock.lockExchangeBind.RLock()
	calls = mock.calls.ExchangeBind
	mock.lockExchangeBind.RUnlock()
	return calls
}

// ExchangeDeclare calls ExchangeDeclareFunc.
func (mock *AmqpChannelMock) ExchangeDeclare(ctx context.Context, name string, exchangeType string, durable bool, autoDelete bool, internal bool, nowait bool, args amqp.AmqpArgs) error {
	if mock.ExchangeDeclareFunc == nil {
		panic("AmqpChannelMock.ExchangeDeclareFunc: method is nil but AmqpChannel.ExchangeDeclare was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Name         string
		ExchangeType string
		Durable      bool
		AutoDelete   bool
		Internal     bool
		Nowait       bool
		Args         amqp.AmqpArgs
	}{
		Ctx:          ctx,
		Name:         name,
		ExchangeType: exchangeType,
		Durable:      durable,
		AutoDelete:   autoDelete,
		Internal:     internal,
		Nowait:       nowait,
		Args:         args,
	}
	mock.lockExchangeDeclare.Lock()
	mock.calls.ExchangeDeclare = append(mock.calls.ExchangeDeclare, callInfo)
	mock.lockExchangeDeclare.Unlock()
	return mock.ExchangeDeclareFunc(ctx, name, exchangeType, durable, autoDelete, internal, nowait, args)
}

// ExchangeDeclareCalls gets all the calls that were made to ExchangeDeclare.
// Check the length with:
//     len(mockedAmqpChannel.ExchangeDeclareCalls())
func (mock *AmqpChannelMock) ExchangeDeclareCalls() []struct {
	Ctx          context.Context
	Name         string
	ExchangeType string
	Durable      bool
	AutoDelete   bool
	Internal     bool
	Nowait       bool
	Args         amqp.AmqpArgs
} {
	var calls []struct {
		Ctx          context.Context
		Name         string
		ExchangeType string
		Durable      bool
		AutoDelete   bool
		Internal     bool
		Nowait       bool
		Args         amqp.AmqpArgs
	}
	mock.lockExchangeDeclare.RLock()
	calls = mock.calls.ExchangeDeclare
	mock.lockExchangeDeclare.RUnlock()
	return calls
}

// ExchangeDelete calls ExchangeDeleteFunc.
func (mock *AmqpChannelMock) ExchangeDelete(ctx context.Context, name string, ifUnused bool, noWait bool) error {
	if mock.ExchangeDeleteFunc == nil {
		panic("AmqpChannelMock.ExchangeDeleteFunc: method is nil but AmqpChannel.ExchangeDelete was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Name     string
		IfUnused bool
		NoWait   bool
	}{
		Ctx:      ctx,
		Name:     name,
		IfUnused: ifUnused,
		NoWait:   noWait,
	}
	mock.lockExchangeDelete.Lock()
	mock.calls.ExchangeDelete = append(mock.calls.ExchangeDelete, callInfo)
	mock.lockExchangeDelete.Unlock()
	return mock.ExchangeDeleteFunc(ctx, name, ifUnused, noWait)
}

// ExchangeDeleteCalls gets all the calls that were made to ExchangeDelete.
// Check the length with:
//     len(mockedAmqpChannel.ExchangeDeleteCalls())
func (mock *AmqpChannelMock) ExchangeDeleteCalls() []struct {
	Ctx      context.Context
	Name     string
	IfUnused bool
	NoWait   bool
} {
	var calls []struct {
		Ctx      context.Context
		Name     string
		IfUnused bool
		NoWait   bool
	}
	mock.lockExchangeDelete.RLock()
	calls = mock.calls.ExchangeDelete
	mock.lockExchangeDelete.RUnlock()
	return calls
}

// ExchangeUnbind calls ExchangeUnbindFunc.
func (mock *AmqpChannelMock) ExchangeUnbind(ctx context.Context, destination string, key string, source string, noWait bool, args amqp.AmqpArgs) error {
	if mock.ExchangeUnbindFunc == nil {
		panic("AmqpChannelMock.ExchangeUnbindFunc: method is nil but AmqpChannel.ExchangeUnbind was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Key         string
		Source      string
		NoWait      bool
		Args        amqp.AmqpArgs
	}{
		Ctx:         ctx,
		Destination: destination,
		Key:         key,
		Source:      source,
		NoWait:      noWait,
		Args:        args,
	}
	mock.lockExchangeUnbind.Lock()
	mock.calls.ExchangeUnbind = append(mock.calls.ExchangeUnbind, callInfo)
	mock.lockExchangeUnbind.Unlock()
	return mock.ExchangeUnbindFunc(ctx, destination, key, source, noWait, args)
}

// ExchangeUnbindCalls gets all the calls that were made to ExchangeUnbind.
// Check the length with:
//     len(mockedAmqpChannel.ExchangeUnbindCalls())
func (mock *AmqpChannelMock) ExchangeUnbindCalls() []struct {
	Ctx         context.Context
	Destination string
	Key         string
	Source      string
	NoWait      bool
	Args        amqp.AmqpArgs
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Key         string
		Source      string
		NoWait      bool
		Args        amqp.AmqpArgs
	}
	mock.lockExchangeUnbind.RLock()
	calls = mock.calls.ExchangeUnbind
	mock.lockExchangeUnbind.RUnlock()
	return calls
}

// Publish calls PublishFunc.
func (mock *AmqpChannelMock) Publish(ctx context.Context, exchange string, key string, mandatory bool, immediate bool, publishing amqp.AmqpPublishing) error {
	if mock.PublishFunc == nil {
		panic("AmqpChannelMock.PublishFunc: method is nil but AmqpChannel.Publish was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Exchange   string
		Key        string
		Mandatory  bool
		Immediate  bool
		Publishing amqp.AmqpPublishing
	}{
		Ctx:        ctx,
		Exchange:   exchange,
		Key:        key,
		Mandatory:  mandatory,
		Immediate:  immediate,
		Publishing: publishing,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	return mock.PublishFunc(ctx, exchange, key, mandatory, immediate, publishing)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//     len(mockedAmqpChannel.PublishCalls())
func (mock *AmqpChannelMock) PublishCalls() []struct {
	Ctx        context.Context
	Exchange   string
	Key        string
	Mandatory  bool
	Immediate  bool
	Publishing amqp.AmqpPublishing
} {
	var calls []struct {
		Ctx        context.Context
		Exchange   string
		Key        string
		Mandatory  bool
		Immediate  bool
		Publishing amqp.AmqpPublishing
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}

// QueueBind calls QueueBindFunc.
func (mock *AmqpChannelMock) QueueBind(ctx context.Context, name string, key string, exchange string, nowait bool, args amqp.AmqpArgs) error {
	if mock.QueueBindFunc == nil {
		panic("AmqpChannelMock.QueueBindFunc: method is nil but AmqpChannel.QueueBind was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Name     string
		Key      string
		Exchange string
		Nowait   bool
		Args     amqp.AmqpArgs
	}{
		Ctx:      ctx,
		Name:     name,
		Key:      key,
		Exchange: exchange,
		Nowait:   nowait,
		Args:     args,
	}
	mock.lockQueueBind.Lock()
	mock.calls.QueueBind = append(mock.calls.QueueBind, callInfo)
	mock.lockQueueBind.Unlock()
	return mock.QueueBindFunc(ctx, name, key, exchange, nowait, args)
}

// QueueBindCalls gets all the calls that were made to QueueBind.
// Check the length with:
//     len(mockedAmqpChannel.QueueBindCalls())
func (mock *AmqpChannelMock) QueueBindCalls() []struct {
	Ctx      context.Context
	Name     string
	Key      string
	Exchange string
	Nowait   bool
	Args     amqp.AmqpArgs
} {
	var calls []struct {
		Ctx      context.Context
		Name     string
		Key      string
		Exchange string
		Nowait   bool
		Args     amqp.AmqpArgs
	}
	mock.lockQueueBind.RLock()
	calls = mock.calls.QueueBind
	mock.lockQueueBind.RUnlock()
	return calls
}

// QueueDeclare calls QueueDeclareFunc.
func (mock *AmqpChannelMock) QueueDeclare(ctx context.Context, name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args amqp.AmqpArgs) error {
	if mock.QueueDeclareFunc == nil {
		panic("AmqpChannelMock.QueueDeclareFunc: method is nil but AmqpChannel.QueueDeclare was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Name       string
		Durable    bool
		AutoDelete bool
		Exclusive  bool
		NoWait     bool
		Args       amqp.AmqpArgs
	}{
		Ctx:        ctx,
		Name:       name,
		Durable:    durable,
		AutoDelete: autoDelete,
		Exclusive:  exclusive,
		NoWait:     noWait,
		Args:       args,
	}
	mock.lockQueueDeclare.Lock()
	mock.calls.QueueDeclare = append(mock.calls.QueueDeclare, callInfo)
	mock.lockQueueDeclare.Unlock()
	return mock.QueueDeclareFunc(ctx, name, durable, autoDelete, exclusive, noWait, args)
}

// QueueDeclareCalls gets all the calls that were made to QueueDeclare.
// Check the length with:
//     len(mockedAmqpChannel.QueueDeclareCalls())
func (mock *AmqpChannelMock) QueueDeclareCalls() []struct {
	Ctx        context.Context
	Name       string
	Durable    bool
	AutoDelete bool
	Exclusive  bool
	NoWait     bool
	Args       amqp.AmqpArgs
} {
	var calls []struct {
		Ctx        context.Context
		Name       string
		Durable    bool
		AutoDelete bool
		Exclusive  bool
		NoWait     bool
		Args       amqp.AmqpArgs
	}
	mock.lockQueueDeclare.RLock()
	calls = mock.calls.QueueDeclare
	mock.lockQueueDeclare.RUnlock()
	return calls
}

// QueueDelete calls QueueDeleteFunc.
func (mock *AmqpChannelMock) QueueDelete(ctx context.Context, name string, ifUnused bool, ifEmpty bool, noWait bool) error {
	if mock.QueueDeleteFunc == nil {
		panic("AmqpChannelMock.QueueDeleteFunc: method is nil but AmqpChannel.QueueDelete was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Name     string
		IfUnused bool
		IfEmpty  bool
		NoWait   bool
	}{
		Ctx:      ctx,
		Name:     name,
		IfUnused: ifUnused,
		IfEmpty:  ifEmpty,
		NoWait:   noWait,
	}
	mock.lockQueueDelete.Lock()
	mock.calls.QueueDelete = append(mock.calls.QueueDelete, callInfo)
	mock.lockQueueDelete.Unlock()
	return mock.QueueDeleteFunc(ctx, name, ifUnused, ifEmpty, noWait)
}

// QueueDeleteCalls gets all the calls that were made to QueueDelete.
// Check the length with:
//     len(mockedAmqpChannel.QueueDeleteCalls())
func (mock *AmqpChannelMock) QueueDeleteCalls() []struct {
	Ctx      context.Context
	Name     string
	IfUnused bool
	IfEmpty  bool
	NoWait   bool
} {
	var calls []struct {
		Ctx      context.Context
		Name     string
		IfUnused bool
		IfEmpty  bool
		NoWait   bool
	}
	mock.lockQueueDelete.RLock()
	calls = mock.calls.QueueDelete
	mock.lockQueueDelete.RUnlock()
	return calls
}

// QueueUnbind calls QueueUnbindFunc.
func (mock *AmqpChannelMock) QueueUnbind(ctx context.Context, name string, key string, exchange string, args amqp.AmqpArgs) error {
	if mock.QueueUnbindFunc == nil {
		panic("AmqpChannelMock.QueueUnbindFunc: method is nil but AmqpChannel.QueueUnbind was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Name     string
		Key      string
		Exchange string
		Args     amqp.AmqpArgs
	}{
		Ctx:      ctx,
		Name:     name,
		Key:      key,
		Exchange: exchange,
		Args:     args,
	}
	mock.lockQueueUnbind.Lock()
	mock.calls.QueueUnbind = append(mock.calls.QueueUnbind, callInfo)
	mock.lockQueueUnbind.Unlock()
	return mock.QueueUnbindFunc(ctx, name, key, exchange, args)
}

// QueueUnbindCalls gets all the calls that were made to QueueUnbind.
// Check the length with:
//     len(mockedAmqpChannel.QueueUnbindCalls())
func (mock *AmqpChannelMock) QueueUnbindCalls() []struct {
	Ctx      context.Context
	Name     string
	Key      string
	Exchange string
	Args     amqp.AmqpArgs
} {
	var calls []struct {
		Ctx      context.Context
		Name     string
		Key      string
		Exchange string
		Args     amqp.AmqpArgs
	}
	mock.lockQueueUnbind.RLock()
	calls = mock.calls.QueueUnbind
	mock.lockQueueUnbind.RUnlock()
	return calls
}
