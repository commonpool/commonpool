// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/commonpool/backend/pkg/keys"
	"github.com/commonpool/backend/pkg/trading"
	"github.com/commonpool/backend/pkg/trading/domain"
	"sync"
)

// Ensure, that TradingService does implement trading.Service.
// If this is not the case, regenerate this file with moq.
var _ trading.Service = &TradingService{}

// TradingService is a mock implementation of trading.Service.
//
//     func TestSomethingThatUsesService(t *testing.T) {
//
//         // make and configure a mocked trading.Service
//         mockedService := &TradingService{
//             AcceptOfferFunc: func(ctx context.Context, offerKey keys.OfferKey) error {
// 	               panic("mock out the AcceptOffer method")
//             },
//             ConfirmBorrowedResourceReturnedFunc: func(ctx context.Context, confirmedItemKey keys.OfferItemKey) error {
// 	               panic("mock out the ConfirmBorrowedResourceReturned method")
//             },
//             ConfirmResourceBorrowedFunc: func(ctx context.Context, confirmedItemKey keys.OfferItemKey) error {
// 	               panic("mock out the ConfirmResourceBorrowed method")
//             },
//             ConfirmResourceTransferredFunc: func(ctx context.Context, confirmedItemKey keys.OfferItemKey) error {
// 	               panic("mock out the ConfirmResourceTransferred method")
//             },
//             ConfirmServiceProvidedFunc: func(ctx context.Context, offerItemKey keys.OfferItemKey) error {
// 	               panic("mock out the ConfirmServiceProvided method")
//             },
//             DeclineOfferFunc: func(ctx context.Context, offerKey keys.OfferKey) error {
// 	               panic("mock out the DeclineOffer method")
//             },
//             FindApproversForOfferFunc: func(offerKey keys.OfferKey) (trading.Approvers, error) {
// 	               panic("mock out the FindApproversForOffer method")
//             },
//             FindApproversForOffersFunc: func(offers *keys.OfferKeys) (*trading.OffersApprovers, error) {
// 	               panic("mock out the FindApproversForOffers method")
//             },
//             FindTargetsForOfferItemFunc: func(ctx context.Context, groupKey keys.GroupKey, itemType trading.OfferItemType, from *resource.Target, to *resource.Target) (*resource.Targets, error) {
// 	               panic("mock out the FindTargetsForOfferItem method")
//             },
//             GetOfferFunc: func(offerKey keys.OfferKey) (*trading.Offer, error) {
// 	               panic("mock out the GetOffer method")
//             },
//             GetOfferItemFunc: func(ctx context.Context, offerItemKey keys.OfferItemKey) (trading.OfferItem, error) {
// 	               panic("mock out the GetOfferItem method")
//             },
//             GetOfferItemsForOfferFunc: func(offerKey keys.OfferKey) (*trading.OfferItems, error) {
// 	               panic("mock out the GetOfferItemsForOffer method")
//             },
//             GetOffersForUserFunc: func(key keys.UserKey) (*trading.GetOffersResult, error) {
// 	               panic("mock out the GetOffersForUser method")
//             },
//             GetTradingHistoryFunc: func(ctx context.Context, userIDs *keys.UserKeys) ([]trading.HistoryEntry, error) {
// 	               panic("mock out the GetTradingHistory method")
//             },
//             SendOfferFunc: func(ctx context.Context, groupKey keys.GroupKey, offerItems *trading.OfferItems, message string) (*trading.Offer, *trading.OfferItems, error) {
// 	               panic("mock out the SendOffer method")
//             },
//         }
//
//         // use mockedService in code that requires trading.Service
//         // and then make assertions.
//
//     }
type TradingService struct {
	// AcceptOfferFunc mocks the AcceptOffer method.
	AcceptOfferFunc func(ctx context.Context, offerKey keys.OfferKey) error

	// ConfirmBorrowedResourceReturnedFunc mocks the ConfirmBorrowedResourceReturned method.
	ConfirmBorrowedResourceReturnedFunc func(ctx context.Context, confirmedItemKey keys.OfferItemKey) error

	// ConfirmResourceBorrowedFunc mocks the ConfirmResourceBorrowed method.
	ConfirmResourceBorrowedFunc func(ctx context.Context, confirmedItemKey keys.OfferItemKey) error

	// ConfirmResourceTransferredFunc mocks the ConfirmResourceTransferred method.
	ConfirmResourceTransferredFunc func(ctx context.Context, confirmedItemKey keys.OfferItemKey) error

	// ConfirmServiceProvidedFunc mocks the ConfirmServiceProvided method.
	ConfirmServiceProvidedFunc func(ctx context.Context, offerItemKey keys.OfferItemKey) error

	// DeclineOfferFunc mocks the DeclineOffer method.
	DeclineOfferFunc func(ctx context.Context, offerKey keys.OfferKey) error

	// FindApproversForOfferFunc mocks the FindApproversForOffer method.
	FindApproversForOfferFunc func(offerKey keys.OfferKey) (trading.Approvers, error)

	// FindApproversForOffersFunc mocks the FindApproversForOffers method.
	FindApproversForOffersFunc func(offers *keys.OfferKeys) (*trading.OffersApprovers, error)

	// FindTargetsForOfferItemFunc mocks the FindTargetsForOfferItem method.
	FindTargetsForOfferItemFunc func(ctx context.Context, groupKey keys.GroupKey, itemType domain.OfferItemType, from *domain.Target, to *domain.Target) (*domain.Targets, error)

	// GetOfferFunc mocks the GetOffer method.
	GetOfferFunc func(offerKey keys.OfferKey) (*trading.Offer, error)

	// GetOfferItemFunc mocks the GetOfferItem method.
	GetOfferItemFunc func(ctx context.Context, offerItemKey keys.OfferItemKey) (domain.OfferItem, error)

	// GetOfferItemsForOfferFunc mocks the GetOfferItemsForOffer method.
	GetOfferItemsForOfferFunc func(offerKey keys.OfferKey) (*domain.OfferItems, error)

	// GetOffersForUserFunc mocks the GetOffersForUser method.
	GetOffersForUserFunc func(key keys.UserKey) (*trading.GetOffersResult, error)

	// GetTradingHistoryFunc mocks the GetTradingHistory method.
	GetTradingHistoryFunc func(ctx context.Context, userIDs *keys.UserKeys) ([]trading.HistoryEntry, error)

	// SendOfferFunc mocks the SendOffer method.
	SendOfferFunc func(ctx context.Context, groupKey keys.GroupKey, offerItems *domain.OfferItems, message string) (*trading.Offer, *domain.OfferItems, error)

	// calls tracks calls to the methods.
	calls struct {
		// AcceptOffer holds details about calls to the AcceptOffer method.
		AcceptOffer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OfferKey is the offerKey argument value.
			OfferKey keys.OfferKey
		}
		// ConfirmBorrowedResourceReturned holds details about calls to the ConfirmBorrowedResourceReturned method.
		ConfirmBorrowedResourceReturned []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ConfirmedItemKey is the confirmedItemKey argument value.
			ConfirmedItemKey keys.OfferItemKey
		}
		// ConfirmResourceBorrowed holds details about calls to the ConfirmResourceBorrowed method.
		ConfirmResourceBorrowed []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ConfirmedItemKey is the confirmedItemKey argument value.
			ConfirmedItemKey keys.OfferItemKey
		}
		// ConfirmResourceTransferred holds details about calls to the ConfirmResourceTransferred method.
		ConfirmResourceTransferred []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ConfirmedItemKey is the confirmedItemKey argument value.
			ConfirmedItemKey keys.OfferItemKey
		}
		// ConfirmServiceProvided holds details about calls to the ConfirmServiceProvided method.
		ConfirmServiceProvided []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OfferItemKey is the offerItemKey argument value.
			OfferItemKey keys.OfferItemKey
		}
		// DeclineOffer holds details about calls to the DeclineOffer method.
		DeclineOffer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OfferKey is the offerKey argument value.
			OfferKey keys.OfferKey
		}
		// FindApproversForOffer holds details about calls to the FindApproversForOffer method.
		FindApproversForOffer []struct {
			// OfferKey is the offerKey argument value.
			OfferKey keys.OfferKey
		}
		// FindApproversForOffers holds details about calls to the FindApproversForOffers method.
		FindApproversForOffers []struct {
			// Offers is the offers argument value.
			Offers *keys.OfferKeys
		}
		// FindTargetsForOfferItem holds details about calls to the FindTargetsForOfferItem method.
		FindTargetsForOfferItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GroupKey is the groupKey argument value.
			GroupKey keys.GroupKey
			// ItemType is the itemType argument value.
			ItemType domain.OfferItemType
			// From is the from argument value.
			From *domain.Target
			// To is the to argument value.
			To *domain.Target
		}
		// GetOffer holds details about calls to the GetOffer method.
		GetOffer []struct {
			// OfferKey is the offerKey argument value.
			OfferKey keys.OfferKey
		}
		// GetOfferItem holds details about calls to the GetOfferItem method.
		GetOfferItem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OfferItemKey is the offerItemKey argument value.
			OfferItemKey keys.OfferItemKey
		}
		// GetOfferItemsForOffer holds details about calls to the GetOfferItemsForOffer method.
		GetOfferItemsForOffer []struct {
			// OfferKey is the offerKey argument value.
			OfferKey keys.OfferKey
		}
		// GetOffersForUser holds details about calls to the GetOffersForUser method.
		GetOffersForUser []struct {
			// Key is the key argument value.
			Key keys.UserKey
		}
		// GetTradingHistory holds details about calls to the GetTradingHistory method.
		GetTradingHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserIDs is the userIDs argument value.
			UserIDs *keys.UserKeys
		}
		// SendOffer holds details about calls to the SendOffer method.
		SendOffer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// GroupKey is the groupKey argument value.
			GroupKey keys.GroupKey
			// OfferItems is the offerItems argument value.
			OfferItems *domain.OfferItems
			// Message is the message argument value.
			Message string
		}
	}
	lockAcceptOffer                     sync.RWMutex
	lockConfirmBorrowedResourceReturned sync.RWMutex
	lockConfirmResourceBorrowed         sync.RWMutex
	lockConfirmResourceTransferred      sync.RWMutex
	lockConfirmServiceProvided          sync.RWMutex
	lockDeclineOffer                    sync.RWMutex
	lockFindApproversForOffer           sync.RWMutex
	lockFindApproversForOffers          sync.RWMutex
	lockFindTargetsForOfferItem         sync.RWMutex
	lockGetOffer                        sync.RWMutex
	lockGetOfferItem                    sync.RWMutex
	lockGetOfferItemsForOffer           sync.RWMutex
	lockGetOffersForUser                sync.RWMutex
	lockGetTradingHistory               sync.RWMutex
	lockSendOffer                       sync.RWMutex
}

// AcceptOffer calls AcceptOfferFunc.
func (mock *TradingService) AcceptOffer(ctx context.Context, offerKey keys.OfferKey) error {
	if mock.AcceptOfferFunc == nil {
		panic("TradingService.AcceptOfferFunc: method is nil but Service.AcceptOffer was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		OfferKey keys.OfferKey
	}{
		Ctx:      ctx,
		OfferKey: offerKey,
	}
	mock.lockAcceptOffer.Lock()
	mock.calls.AcceptOffer = append(mock.calls.AcceptOffer, callInfo)
	mock.lockAcceptOffer.Unlock()
	return mock.AcceptOfferFunc(ctx, offerKey)
}

// AcceptOfferCalls gets all the calls that were made to AcceptOffer.
// Check the length with:
//     len(mockedService.AcceptOfferCalls())
func (mock *TradingService) AcceptOfferCalls() []struct {
	Ctx      context.Context
	OfferKey keys.OfferKey
} {
	var calls []struct {
		Ctx      context.Context
		OfferKey keys.OfferKey
	}
	mock.lockAcceptOffer.RLock()
	calls = mock.calls.AcceptOffer
	mock.lockAcceptOffer.RUnlock()
	return calls
}

// ConfirmBorrowedResourceReturned calls ConfirmBorrowedResourceReturnedFunc.
func (mock *TradingService) ConfirmBorrowedResourceReturned(ctx context.Context, confirmedItemKey keys.OfferItemKey) error {
	if mock.ConfirmBorrowedResourceReturnedFunc == nil {
		panic("TradingService.ConfirmBorrowedResourceReturnedFunc: method is nil but Service.ConfirmBorrowedResourceReturned was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		ConfirmedItemKey keys.OfferItemKey
	}{
		Ctx:              ctx,
		ConfirmedItemKey: confirmedItemKey,
	}
	mock.lockConfirmBorrowedResourceReturned.Lock()
	mock.calls.ConfirmBorrowedResourceReturned = append(mock.calls.ConfirmBorrowedResourceReturned, callInfo)
	mock.lockConfirmBorrowedResourceReturned.Unlock()
	return mock.ConfirmBorrowedResourceReturnedFunc(ctx, confirmedItemKey)
}

// ConfirmBorrowedResourceReturnedCalls gets all the calls that were made to ConfirmBorrowedResourceReturned.
// Check the length with:
//     len(mockedService.ConfirmBorrowedResourceReturnedCalls())
func (mock *TradingService) ConfirmBorrowedResourceReturnedCalls() []struct {
	Ctx              context.Context
	ConfirmedItemKey keys.OfferItemKey
} {
	var calls []struct {
		Ctx              context.Context
		ConfirmedItemKey keys.OfferItemKey
	}
	mock.lockConfirmBorrowedResourceReturned.RLock()
	calls = mock.calls.ConfirmBorrowedResourceReturned
	mock.lockConfirmBorrowedResourceReturned.RUnlock()
	return calls
}

// ConfirmResourceBorrowed calls ConfirmResourceBorrowedFunc.
func (mock *TradingService) ConfirmResourceBorrowed(ctx context.Context, confirmedItemKey keys.OfferItemKey) error {
	if mock.ConfirmResourceBorrowedFunc == nil {
		panic("TradingService.ConfirmResourceBorrowedFunc: method is nil but Service.ConfirmResourceBorrowed was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		ConfirmedItemKey keys.OfferItemKey
	}{
		Ctx:              ctx,
		ConfirmedItemKey: confirmedItemKey,
	}
	mock.lockConfirmResourceBorrowed.Lock()
	mock.calls.ConfirmResourceBorrowed = append(mock.calls.ConfirmResourceBorrowed, callInfo)
	mock.lockConfirmResourceBorrowed.Unlock()
	return mock.ConfirmResourceBorrowedFunc(ctx, confirmedItemKey)
}

// ConfirmResourceBorrowedCalls gets all the calls that were made to ConfirmResourceBorrowed.
// Check the length with:
//     len(mockedService.ConfirmResourceBorrowedCalls())
func (mock *TradingService) ConfirmResourceBorrowedCalls() []struct {
	Ctx              context.Context
	ConfirmedItemKey keys.OfferItemKey
} {
	var calls []struct {
		Ctx              context.Context
		ConfirmedItemKey keys.OfferItemKey
	}
	mock.lockConfirmResourceBorrowed.RLock()
	calls = mock.calls.ConfirmResourceBorrowed
	mock.lockConfirmResourceBorrowed.RUnlock()
	return calls
}

// ConfirmResourceTransferred calls ConfirmResourceTransferredFunc.
func (mock *TradingService) ConfirmResourceTransferred(ctx context.Context, confirmedItemKey keys.OfferItemKey) error {
	if mock.ConfirmResourceTransferredFunc == nil {
		panic("TradingService.ConfirmResourceTransferredFunc: method is nil but Service.ConfirmResourceTransferred was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		ConfirmedItemKey keys.OfferItemKey
	}{
		Ctx:              ctx,
		ConfirmedItemKey: confirmedItemKey,
	}
	mock.lockConfirmResourceTransferred.Lock()
	mock.calls.ConfirmResourceTransferred = append(mock.calls.ConfirmResourceTransferred, callInfo)
	mock.lockConfirmResourceTransferred.Unlock()
	return mock.ConfirmResourceTransferredFunc(ctx, confirmedItemKey)
}

// ConfirmResourceTransferredCalls gets all the calls that were made to ConfirmResourceTransferred.
// Check the length with:
//     len(mockedService.ConfirmResourceTransferredCalls())
func (mock *TradingService) ConfirmResourceTransferredCalls() []struct {
	Ctx              context.Context
	ConfirmedItemKey keys.OfferItemKey
} {
	var calls []struct {
		Ctx              context.Context
		ConfirmedItemKey keys.OfferItemKey
	}
	mock.lockConfirmResourceTransferred.RLock()
	calls = mock.calls.ConfirmResourceTransferred
	mock.lockConfirmResourceTransferred.RUnlock()
	return calls
}

// ConfirmServiceProvided calls ConfirmServiceProvidedFunc.
func (mock *TradingService) ConfirmServiceProvided(ctx context.Context, offerItemKey keys.OfferItemKey) error {
	if mock.ConfirmServiceProvidedFunc == nil {
		panic("TradingService.ConfirmServiceProvidedFunc: method is nil but Service.ConfirmServiceProvided was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		OfferItemKey keys.OfferItemKey
	}{
		Ctx:          ctx,
		OfferItemKey: offerItemKey,
	}
	mock.lockConfirmServiceProvided.Lock()
	mock.calls.ConfirmServiceProvided = append(mock.calls.ConfirmServiceProvided, callInfo)
	mock.lockConfirmServiceProvided.Unlock()
	return mock.ConfirmServiceProvidedFunc(ctx, offerItemKey)
}

// ConfirmServiceProvidedCalls gets all the calls that were made to ConfirmServiceProvided.
// Check the length with:
//     len(mockedService.ConfirmServiceProvidedCalls())
func (mock *TradingService) ConfirmServiceProvidedCalls() []struct {
	Ctx          context.Context
	OfferItemKey keys.OfferItemKey
} {
	var calls []struct {
		Ctx          context.Context
		OfferItemKey keys.OfferItemKey
	}
	mock.lockConfirmServiceProvided.RLock()
	calls = mock.calls.ConfirmServiceProvided
	mock.lockConfirmServiceProvided.RUnlock()
	return calls
}

// DeclineOffer calls DeclineOfferFunc.
func (mock *TradingService) DeclineOffer(ctx context.Context, offerKey keys.OfferKey) error {
	if mock.DeclineOfferFunc == nil {
		panic("TradingService.DeclineOfferFunc: method is nil but Service.DeclineOffer was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		OfferKey keys.OfferKey
	}{
		Ctx:      ctx,
		OfferKey: offerKey,
	}
	mock.lockDeclineOffer.Lock()
	mock.calls.DeclineOffer = append(mock.calls.DeclineOffer, callInfo)
	mock.lockDeclineOffer.Unlock()
	return mock.DeclineOfferFunc(ctx, offerKey)
}

// DeclineOfferCalls gets all the calls that were made to DeclineOffer.
// Check the length with:
//     len(mockedService.DeclineOfferCalls())
func (mock *TradingService) DeclineOfferCalls() []struct {
	Ctx      context.Context
	OfferKey keys.OfferKey
} {
	var calls []struct {
		Ctx      context.Context
		OfferKey keys.OfferKey
	}
	mock.lockDeclineOffer.RLock()
	calls = mock.calls.DeclineOffer
	mock.lockDeclineOffer.RUnlock()
	return calls
}

// FindApproversForOffer calls FindApproversForOfferFunc.
func (mock *TradingService) FindApproversForOffer(offerKey keys.OfferKey) (trading.Approvers, error) {
	if mock.FindApproversForOfferFunc == nil {
		panic("TradingService.FindApproversForOfferFunc: method is nil but Service.FindApproversForOffer was just called")
	}
	callInfo := struct {
		OfferKey keys.OfferKey
	}{
		OfferKey: offerKey,
	}
	mock.lockFindApproversForOffer.Lock()
	mock.calls.FindApproversForOffer = append(mock.calls.FindApproversForOffer, callInfo)
	mock.lockFindApproversForOffer.Unlock()
	return mock.FindApproversForOfferFunc(offerKey)
}

// FindApproversForOfferCalls gets all the calls that were made to FindApproversForOffer.
// Check the length with:
//     len(mockedService.FindApproversForOfferCalls())
func (mock *TradingService) FindApproversForOfferCalls() []struct {
	OfferKey keys.OfferKey
} {
	var calls []struct {
		OfferKey keys.OfferKey
	}
	mock.lockFindApproversForOffer.RLock()
	calls = mock.calls.FindApproversForOffer
	mock.lockFindApproversForOffer.RUnlock()
	return calls
}

// FindApproversForOffers calls FindApproversForOffersFunc.
func (mock *TradingService) FindApproversForOffers(offers *keys.OfferKeys) (*trading.OffersApprovers, error) {
	if mock.FindApproversForOffersFunc == nil {
		panic("TradingService.FindApproversForOffersFunc: method is nil but Service.FindApproversForOffers was just called")
	}
	callInfo := struct {
		Offers *keys.OfferKeys
	}{
		Offers: offers,
	}
	mock.lockFindApproversForOffers.Lock()
	mock.calls.FindApproversForOffers = append(mock.calls.FindApproversForOffers, callInfo)
	mock.lockFindApproversForOffers.Unlock()
	return mock.FindApproversForOffersFunc(offers)
}

// FindApproversForOffersCalls gets all the calls that were made to FindApproversForOffers.
// Check the length with:
//     len(mockedService.FindApproversForOffersCalls())
func (mock *TradingService) FindApproversForOffersCalls() []struct {
	Offers *keys.OfferKeys
} {
	var calls []struct {
		Offers *keys.OfferKeys
	}
	mock.lockFindApproversForOffers.RLock()
	calls = mock.calls.FindApproversForOffers
	mock.lockFindApproversForOffers.RUnlock()
	return calls
}

// FindTargetsForOfferItem calls FindTargetsForOfferItemFunc.
func (mock *TradingService) FindTargetsForOfferItem(ctx context.Context, groupKey keys.GroupKey, itemType domain.OfferItemType, from *domain.Target, to *domain.Target) (*domain.Targets, error) {
	if mock.FindTargetsForOfferItemFunc == nil {
		panic("TradingService.FindTargetsForOfferItemFunc: method is nil but Service.FindTargetsForOfferItem was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		GroupKey keys.GroupKey
		ItemType domain.OfferItemType
		From     *domain.Target
		To       *domain.Target
	}{
		Ctx:      ctx,
		GroupKey: groupKey,
		ItemType: itemType,
		From:     from,
		To:       to,
	}
	mock.lockFindTargetsForOfferItem.Lock()
	mock.calls.FindTargetsForOfferItem = append(mock.calls.FindTargetsForOfferItem, callInfo)
	mock.lockFindTargetsForOfferItem.Unlock()
	return mock.FindTargetsForOfferItemFunc(ctx, groupKey, itemType, from, to)
}

// FindTargetsForOfferItemCalls gets all the calls that were made to FindTargetsForOfferItem.
// Check the length with:
//     len(mockedService.FindTargetsForOfferItemCalls())
func (mock *TradingService) FindTargetsForOfferItemCalls() []struct {
	Ctx      context.Context
	GroupKey keys.GroupKey
	ItemType domain.OfferItemType
	From     *domain.Target
	To       *domain.Target
} {
	var calls []struct {
		Ctx      context.Context
		GroupKey keys.GroupKey
		ItemType domain.OfferItemType
		From     *domain.Target
		To       *domain.Target
	}
	mock.lockFindTargetsForOfferItem.RLock()
	calls = mock.calls.FindTargetsForOfferItem
	mock.lockFindTargetsForOfferItem.RUnlock()
	return calls
}

// GetOffer calls GetOfferFunc.
func (mock *TradingService) GetOffer(offerKey keys.OfferKey) (*trading.Offer, error) {
	if mock.GetOfferFunc == nil {
		panic("TradingService.GetOfferFunc: method is nil but Service.GetOffer was just called")
	}
	callInfo := struct {
		OfferKey keys.OfferKey
	}{
		OfferKey: offerKey,
	}
	mock.lockGetOffer.Lock()
	mock.calls.GetOffer = append(mock.calls.GetOffer, callInfo)
	mock.lockGetOffer.Unlock()
	return mock.GetOfferFunc(offerKey)
}

// GetOfferCalls gets all the calls that were made to GetOffer.
// Check the length with:
//     len(mockedService.GetOfferCalls())
func (mock *TradingService) GetOfferCalls() []struct {
	OfferKey keys.OfferKey
} {
	var calls []struct {
		OfferKey keys.OfferKey
	}
	mock.lockGetOffer.RLock()
	calls = mock.calls.GetOffer
	mock.lockGetOffer.RUnlock()
	return calls
}

// GetOfferItem calls GetOfferItemFunc.
func (mock *TradingService) GetOfferItem(ctx context.Context, offerItemKey keys.OfferItemKey) (domain.OfferItem, error) {
	if mock.GetOfferItemFunc == nil {
		panic("TradingService.GetOfferItemFunc: method is nil but Service.GetOfferItem was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		OfferItemKey keys.OfferItemKey
	}{
		Ctx:          ctx,
		OfferItemKey: offerItemKey,
	}
	mock.lockGetOfferItem.Lock()
	mock.calls.GetOfferItem = append(mock.calls.GetOfferItem, callInfo)
	mock.lockGetOfferItem.Unlock()
	return mock.GetOfferItemFunc(ctx, offerItemKey)
}

// GetOfferItemCalls gets all the calls that were made to GetOfferItem.
// Check the length with:
//     len(mockedService.GetOfferItemCalls())
func (mock *TradingService) GetOfferItemCalls() []struct {
	Ctx          context.Context
	OfferItemKey keys.OfferItemKey
} {
	var calls []struct {
		Ctx          context.Context
		OfferItemKey keys.OfferItemKey
	}
	mock.lockGetOfferItem.RLock()
	calls = mock.calls.GetOfferItem
	mock.lockGetOfferItem.RUnlock()
	return calls
}

// GetOfferItemsForOffer calls GetOfferItemsForOfferFunc.
func (mock *TradingService) GetOfferItemsForOffer(offerKey keys.OfferKey) (*domain.OfferItems, error) {
	if mock.GetOfferItemsForOfferFunc == nil {
		panic("TradingService.GetOfferItemsForOfferFunc: method is nil but Service.GetOfferItemsForOffer was just called")
	}
	callInfo := struct {
		OfferKey keys.OfferKey
	}{
		OfferKey: offerKey,
	}
	mock.lockGetOfferItemsForOffer.Lock()
	mock.calls.GetOfferItemsForOffer = append(mock.calls.GetOfferItemsForOffer, callInfo)
	mock.lockGetOfferItemsForOffer.Unlock()
	return mock.GetOfferItemsForOfferFunc(offerKey)
}

// GetOfferItemsForOfferCalls gets all the calls that were made to GetOfferItemsForOffer.
// Check the length with:
//     len(mockedService.GetOfferItemsForOfferCalls())
func (mock *TradingService) GetOfferItemsForOfferCalls() []struct {
	OfferKey keys.OfferKey
} {
	var calls []struct {
		OfferKey keys.OfferKey
	}
	mock.lockGetOfferItemsForOffer.RLock()
	calls = mock.calls.GetOfferItemsForOffer
	mock.lockGetOfferItemsForOffer.RUnlock()
	return calls
}

// GetOffersForUser calls GetOffersForUserFunc.
func (mock *TradingService) GetOffersForUser(key keys.UserKey) (*trading.GetOffersResult, error) {
	if mock.GetOffersForUserFunc == nil {
		panic("TradingService.GetOffersForUserFunc: method is nil but Service.GetOffersForUser was just called")
	}
	callInfo := struct {
		Key keys.UserKey
	}{
		Key: key,
	}
	mock.lockGetOffersForUser.Lock()
	mock.calls.GetOffersForUser = append(mock.calls.GetOffersForUser, callInfo)
	mock.lockGetOffersForUser.Unlock()
	return mock.GetOffersForUserFunc(key)
}

// GetOffersForUserCalls gets all the calls that were made to GetOffersForUser.
// Check the length with:
//     len(mockedService.GetOffersForUserCalls())
func (mock *TradingService) GetOffersForUserCalls() []struct {
	Key keys.UserKey
} {
	var calls []struct {
		Key keys.UserKey
	}
	mock.lockGetOffersForUser.RLock()
	calls = mock.calls.GetOffersForUser
	mock.lockGetOffersForUser.RUnlock()
	return calls
}

// GetTradingHistory calls GetTradingHistoryFunc.
func (mock *TradingService) GetTradingHistory(ctx context.Context, userIDs *keys.UserKeys) ([]trading.HistoryEntry, error) {
	if mock.GetTradingHistoryFunc == nil {
		panic("TradingService.GetTradingHistoryFunc: method is nil but Service.GetTradingHistory was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserIDs *keys.UserKeys
	}{
		Ctx:     ctx,
		UserIDs: userIDs,
	}
	mock.lockGetTradingHistory.Lock()
	mock.calls.GetTradingHistory = append(mock.calls.GetTradingHistory, callInfo)
	mock.lockGetTradingHistory.Unlock()
	return mock.GetTradingHistoryFunc(ctx, userIDs)
}

// GetTradingHistoryCalls gets all the calls that were made to GetTradingHistory.
// Check the length with:
//     len(mockedService.GetTradingHistoryCalls())
func (mock *TradingService) GetTradingHistoryCalls() []struct {
	Ctx     context.Context
	UserIDs *keys.UserKeys
} {
	var calls []struct {
		Ctx     context.Context
		UserIDs *keys.UserKeys
	}
	mock.lockGetTradingHistory.RLock()
	calls = mock.calls.GetTradingHistory
	mock.lockGetTradingHistory.RUnlock()
	return calls
}

// SendOffer calls SendOfferFunc.
func (mock *TradingService) SendOffer(ctx context.Context, groupKey keys.GroupKey, offerItems *domain.OfferItems, message string) (*trading.Offer, *domain.OfferItems, error) {
	if mock.SendOfferFunc == nil {
		panic("TradingService.SendOfferFunc: method is nil but Service.SendOffer was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		GroupKey   keys.GroupKey
		OfferItems *domain.OfferItems
		Message    string
	}{
		Ctx:        ctx,
		GroupKey:   groupKey,
		OfferItems: offerItems,
		Message:    message,
	}
	mock.lockSendOffer.Lock()
	mock.calls.SendOffer = append(mock.calls.SendOffer, callInfo)
	mock.lockSendOffer.Unlock()
	return mock.SendOfferFunc(ctx, groupKey, offerItems, message)
}

// SendOfferCalls gets all the calls that were made to SendOffer.
// Check the length with:
//     len(mockedService.SendOfferCalls())
func (mock *TradingService) SendOfferCalls() []struct {
	Ctx        context.Context
	GroupKey   keys.GroupKey
	OfferItems *domain.OfferItems
	Message    string
} {
	var calls []struct {
		Ctx        context.Context
		GroupKey   keys.GroupKey
		OfferItems *domain.OfferItems
		Message    string
	}
	mock.lockSendOffer.RLock()
	calls = mock.calls.SendOffer
	mock.lockSendOffer.RUnlock()
	return calls
}
