// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/commonpool/backend/pkg/auth"
	"github.com/commonpool/backend/pkg/user/usermodel"
	"github.com/labstack/echo/v4"
	"net/http"
	"sync"
)

// Ensure, that AuthenticatorMock does implement auth.Authenticator.
// If this is not the case, regenerate this file with moq.
var _ auth.Authenticator = &AuthenticatorMock{}

// AuthenticatorMock is a mock implementation of auth.Authenticator.
//
//     func TestSomethingThatUsesAuthenticator(t *testing.T) {
//
//         // make and configure a mocked auth.Authenticator
//         mockedAuthenticator := &AuthenticatorMock{
//             AuthenticateFunc: func(redirectOnError bool) echo.MiddlewareFunc {
// 	               panic("mock out the Authenticate method")
//             },
//             GetLoggedInUserFunc: func(ctx context.Context) (usermodel.UserReference, error) {
// 	               panic("mock out the GetLoggedInUser method")
//             },
//             GetRedirectResponseFunc: func(request *http.Request) (*auth.RedirectResponse, error) {
// 	               panic("mock out the GetRedirectResponse method")
//             },
//             LoginFunc: func() echo.HandlerFunc {
// 	               panic("mock out the Login method")
//             },
//             LogoutFunc: func() echo.HandlerFunc {
// 	               panic("mock out the Logout method")
//             },
//         }
//
//         // use mockedAuthenticator in code that requires auth.Authenticator
//         // and then make assertions.
//
//     }
type AuthenticatorMock struct {
	// AuthenticateFunc mocks the Authenticate method.
	AuthenticateFunc func(redirectOnError bool) echo.MiddlewareFunc

	// GetLoggedInUserFunc mocks the GetLoggedInUser method.
	GetLoggedInUserFunc func(ctx context.Context) (usermodel.UserReference, error)

	// GetRedirectResponseFunc mocks the GetRedirectResponse method.
	GetRedirectResponseFunc func(request *http.Request) (*auth.RedirectResponse, error)

	// LoginFunc mocks the Login method.
	LoginFunc func() echo.HandlerFunc

	// LogoutFunc mocks the Logout method.
	LogoutFunc func() echo.HandlerFunc

	// calls tracks calls to the methods.
	calls struct {
		// Authenticate holds details about calls to the Authenticate method.
		Authenticate []struct {
			// RedirectOnError is the redirectOnError argument value.
			RedirectOnError bool
		}
		// GetLoggedInUser holds details about calls to the GetLoggedInUser method.
		GetLoggedInUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetRedirectResponse holds details about calls to the GetRedirectResponse method.
		GetRedirectResponse []struct {
			// Request is the request argument value.
			Request *http.Request
		}
		// Login holds details about calls to the Login method.
		Login []struct {
		}
		// Logout holds details about calls to the Logout method.
		Logout []struct {
		}
	}
	lockAuthenticate        sync.RWMutex
	lockGetLoggedInUser     sync.RWMutex
	lockGetRedirectResponse sync.RWMutex
	lockLogin               sync.RWMutex
	lockLogout              sync.RWMutex
}

// Authenticate calls AuthenticateFunc.
func (mock *AuthenticatorMock) Authenticate(redirectOnError bool) echo.MiddlewareFunc {
	if mock.AuthenticateFunc == nil {
		panic("AuthenticatorMock.AuthenticateFunc: method is nil but Authenticator.Authenticate was just called")
	}
	callInfo := struct {
		RedirectOnError bool
	}{
		RedirectOnError: redirectOnError,
	}
	mock.lockAuthenticate.Lock()
	mock.calls.Authenticate = append(mock.calls.Authenticate, callInfo)
	mock.lockAuthenticate.Unlock()
	return mock.AuthenticateFunc(redirectOnError)
}

// AuthenticateCalls gets all the calls that were made to Authenticate.
// Check the length with:
//     len(mockedAuthenticator.AuthenticateCalls())
func (mock *AuthenticatorMock) AuthenticateCalls() []struct {
	RedirectOnError bool
} {
	var calls []struct {
		RedirectOnError bool
	}
	mock.lockAuthenticate.RLock()
	calls = mock.calls.Authenticate
	mock.lockAuthenticate.RUnlock()
	return calls
}

// GetLoggedInUser calls GetLoggedInUserFunc.
func (mock *AuthenticatorMock) GetLoggedInUser(ctx context.Context) (usermodel.UserReference, error) {
	if mock.GetLoggedInUserFunc == nil {
		panic("AuthenticatorMock.GetLoggedInUserFunc: method is nil but Authenticator.GetLoggedInUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLoggedInUser.Lock()
	mock.calls.GetLoggedInUser = append(mock.calls.GetLoggedInUser, callInfo)
	mock.lockGetLoggedInUser.Unlock()
	return mock.GetLoggedInUserFunc(ctx)
}

// GetLoggedInUserCalls gets all the calls that were made to GetLoggedInUser.
// Check the length with:
//     len(mockedAuthenticator.GetLoggedInUserCalls())
func (mock *AuthenticatorMock) GetLoggedInUserCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetLoggedInUser.RLock()
	calls = mock.calls.GetLoggedInUser
	mock.lockGetLoggedInUser.RUnlock()
	return calls
}

// GetRedirectResponse calls GetRedirectResponseFunc.
func (mock *AuthenticatorMock) GetRedirectResponse(request *http.Request) (*auth.RedirectResponse, error) {
	if mock.GetRedirectResponseFunc == nil {
		panic("AuthenticatorMock.GetRedirectResponseFunc: method is nil but Authenticator.GetRedirectResponse was just called")
	}
	callInfo := struct {
		Request *http.Request
	}{
		Request: request,
	}
	mock.lockGetRedirectResponse.Lock()
	mock.calls.GetRedirectResponse = append(mock.calls.GetRedirectResponse, callInfo)
	mock.lockGetRedirectResponse.Unlock()
	return mock.GetRedirectResponseFunc(request)
}

// GetRedirectResponseCalls gets all the calls that were made to GetRedirectResponse.
// Check the length with:
//     len(mockedAuthenticator.GetRedirectResponseCalls())
func (mock *AuthenticatorMock) GetRedirectResponseCalls() []struct {
	Request *http.Request
} {
	var calls []struct {
		Request *http.Request
	}
	mock.lockGetRedirectResponse.RLock()
	calls = mock.calls.GetRedirectResponse
	mock.lockGetRedirectResponse.RUnlock()
	return calls
}

// Login calls LoginFunc.
func (mock *AuthenticatorMock) Login() echo.HandlerFunc {
	if mock.LoginFunc == nil {
		panic("AuthenticatorMock.LoginFunc: method is nil but Authenticator.Login was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLogin.Lock()
	mock.calls.Login = append(mock.calls.Login, callInfo)
	mock.lockLogin.Unlock()
	return mock.LoginFunc()
}

// LoginCalls gets all the calls that were made to Login.
// Check the length with:
//     len(mockedAuthenticator.LoginCalls())
func (mock *AuthenticatorMock) LoginCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLogin.RLock()
	calls = mock.calls.Login
	mock.lockLogin.RUnlock()
	return calls
}

// Logout calls LogoutFunc.
func (mock *AuthenticatorMock) Logout() echo.HandlerFunc {
	if mock.LogoutFunc == nil {
		panic("AuthenticatorMock.LogoutFunc: method is nil but Authenticator.Logout was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLogout.Lock()
	mock.calls.Logout = append(mock.calls.Logout, callInfo)
	mock.lockLogout.Unlock()
	return mock.LogoutFunc()
}

// LogoutCalls gets all the calls that were made to Logout.
// Check the length with:
//     len(mockedAuthenticator.LogoutCalls())
func (mock *AuthenticatorMock) LogoutCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLogout.RLock()
	calls = mock.calls.Logout
	mock.lockLogout.RUnlock()
	return calls
}
